struct VIn
{
    float4 p   : POSITION;
    float3 n   : NORMAL;
    float2 uv  : TEXCOORD0;
};

struct VOut
{
    float4 p   : POSITION;
    float2 uv  : TEXCOORD0;
  
};

struct PIn
{
    float2 uv  : TEXCOORD0;
 
};

VOut motionblur_vs(VIn IN, uniform float4x4 wvp)
{
    VOut OUT;
    OUT.p = mul(wvp, IN.p);
    // clean up inaccuracies for the UV coords
    float2 uv = sign(IN.p);
    // convert to image space
    uv = (float2(uv.x, -uv.y) + 1.0) * 0.5;
    OUT.uv = uv;
  
    return OUT;
}


// for ps_3_0, we want to use tex2Dlod because it's faster
ps_3_0 float4 TEX2DLOD(sampler2D map, float2 uv)
{
    return tex2Dlod(map, float4(uv.xy, 0, 0));
}

float4 TEX2DLOD(sampler2D map, float2 uv)
{
    return tex2D(map, uv);
}

// for ps_3_0, we want to use tex1Dlod because it's faster
ps_3_0 float4 TEX1DLOD(sampler1D map, float u)
{
    return tex1Dlod(map, u);
}

float4 TEX1DLOD(sampler1D map, float u)
{
    return tex1D(map, u);
}


float4 motionblur_ps(
    PIn IN,
    uniform sampler2D geomMap    : TEXUNIT0,
    uniform sampler2D scene      : TEXUNIT1 ) : COLOR0
{
 
   float2 velocity = TEX2DLOD( geomMap, IN.uv ).rg * 0.1;

   float  count        = 0.0;
   float  g_numSamples = 16.0;

   float4 color        = float4(0,0,0,0);
  
   for( float i = 0.0; i < g_numSamples; ++i )  
   {  
	float2 lookup =  IN.uv + velocity * i/ g_numSamples;

  	// Sample the color buffer along the velocity vector.  
   	float4 currentColor = TEX2DLOD( scene, lookup);  
  	
	// Add the current color to our color sum.  
  	color += currentColor;  
	count++;
	
   } 

   return color / count;		 
}



