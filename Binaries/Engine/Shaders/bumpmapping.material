//------------------------
// Bump mapping section
//------------------------

// Bump map vertex program, support for this is required
vertex_program BumpMapVPCg cg
{
	source BumpMapping.cg
	entry_point main_vp
	profiles vs_4_0 vs_1_1 arbvp1
}

vertex_program BumpMapVPGLSLES glsles
{
	source BumpMappingVp.glsles
	profiles glsles
}

vertex_program BumpMapVP unified
{
	delegate BumpMapVPGLSLES
	delegate BumpMapVPCg
}

// Bump map vertex program, with tangent parity support for this is required
vertex_program BumpMapVPTangentParity cg
{
	source BumpMapping.cg
	entry_point main_vp
	profiles vs_1_1 arbvp1
	compile_arguments -DTANGENTS_HAVE_PARITY=1
}

// Bump map fragment program, support for this is optional
fragment_program BumpMapFPCg cg
{
	source BumpMapping.cg
	entry_point main_fp
	profiles ps_4_0 ps_2_0 arbfp1 fp20
}

fragment_program BumpMapFPGLSLES glsles
{
	source BumpMappingFp.glsles
	profiles glsles
	default_params
	{
		// assign samplers as required by GLSL
		param_named normalMap int 0
	}
}

fragment_program BumpMapFP unified
{
	delegate BumpMapFPGLSLES
	delegate BumpMapFPCg
}

// Bump map vertex program shadow receiver
vertex_program BumpMapVPShadowRcvCg cg
{
	source BumpMapping.cg
	entry_point main_shadowreceiver_vp
	profiles vs_1_1 arbvp1
}

// Bump map vertex program shadow receiver
vertex_program BumpMapVPShadowRcvGLSLES glsles
{
	source BumpMappingShadowRcvVp.glsles
	profiles glsles
}

vertex_program BumpMapVPShadowRcv unified
{
	delegate BumpMapVPShadowRcvGLSLES
	delegate BumpMapVPShadowRcvCg
}

// Bump map fragment program shadow receiver, support for this is optional
fragment_program BumpMapFPShadowRcvCg cg
{
	source BumpMapping.cg
	entry_point main_shadowreceiver_fp
	profiles ps_2_0 arbfp1 fp20
}

// Bump map fragment program shadow receiver, support for this is optional
fragment_program BumpMapFPShadowRcvGLSLES glsles
{
	source BumpMappingShadowRcvFp.glsles
	profiles glsles
	default_params
	{
		// assign samplers as required by GLSL
		param_named shadowMap int 0
		param_named normalMap int 1
	}
}

fragment_program BumpMapFPShadowRcv unified
{
	delegate BumpMapFPShadowRcvGLSLES
	delegate BumpMapFPShadowRcvCg
}

// Bump map with specular vertex program, support for this is required
vertex_program BumpMapVPSpecularCg cg
{
	source BumpMapping.cg
	entry_point specular_vp
	profiles vs_4_0 vs_1_1 arbvp1
}

// Bump map with specular vertex program, support for this is required
vertex_program BumpMapVPSpecularGLSLES glsles
{
	source BumpMappingSpecularVp.glsles
	profiles glsles
}

vertex_program BumpMapVPSpecular unified
{
	delegate BumpMapVPSpecularGLSLES
	delegate BumpMapVPSpecularCg
}

// Bump map fragment program, support for this is optional
fragment_program BumpMapFPSpecularCg cg
{
	source BumpMapping.cg
	entry_point specular_fp
	profiles ps_4_0 ps_2_0 arbfp1 fp20
}

// Bump map fragment program, support for this is optional
fragment_program BumpMapFPSpecularGLSLES glsles
{
	source BumpMappingSpecularFp.glsles
	profiles glsles
	default_params
	{
		// assign samplers as required by GLSL
		param_named normalMap int 0
	}
}

fragment_program BumpMapFPSpecular unified
{
	delegate BumpMapFPSpecularGLSLES
	delegate BumpMapFPSpecularCg
}

// Any number of lights, diffuse
material BumpMapping/MultiLight
{

	// This is the preferred technique which uses both vertex and
	// fragment programs, supports coloured lights
	technique
	{
		// Base ambient pass
		pass ambient
		{
			// base colours, not needed for rendering, but as information
			// to lighting pass categorisation routine
			ambient 1 1 1
			diffuse 0 0 0 
			specular 0 0 0 0 
			// Really basic vertex program
			// NB we don't use fixed function here because GL does not like
			// mixing fixed function and vertex programs, depth fighting can
			// be an issue
			vertex_program_ref BasicVertexPrograms/AmbientOneTextureUnified
			{
				param_named_auto ambient ambient_light_colour
			}
			fragment_program_ref BasicFragmentPrograms/PassthroughFP
			{
			}
			
		}
		// Now do the lighting pass
		// NB we don't do decal texture here because this is repeated per light
		pass perlight
		{
			// base colours, not needed for rendering, but as information
			// to lighting pass categorisation routine
			ambient 0 0 0 
			
			// do this for each light
			iteration once_per_light

		
			scene_blend add

			// Vertex program reference
			vertex_program_ref BumpMapVP
			{
				param_named_auto lightPosition light_position_object_space 0
				param_named_auto worldViewProj worldviewproj_matrix
			}

			// Fragment program
			fragment_program_ref BumpMapFP
			{
				param_named_auto lightDiffuse light_diffuse_colour 0 
			}

			// texture shadow receiver program
			shadow_receiver_vertex_program_ref BumpMapVPShadowRcv
			{
				param_named_auto lightPosition light_position_object_space 0
				param_named_auto worldViewProj worldviewproj_matrix
				param_named_auto worldMatrix world_matrix
				param_named_auto texViewProj texture_viewproj_matrix
			}
			// Additive texture shadow receiver program
			shadow_receiver_fragment_program_ref BumpMapFPShadowRcv
			{
				param_named_auto lightDiffuse light_diffuse_colour 0 
			}
			
			// Base bump map
			texture_unit normalmap
			{
				texture NMBumpsOut.png
				colour_op replace
			}
		}
		
		// Decal pass
		pass decal
		{
			// base colours, not needed for rendering, but as information
			// to lighting pass categorisation routine
			lighting off
			// Really basic vertex program
			// NB we don't use fixed function here because GL does not like
			// mixing fixed function and vertex programs, depth fighting can
			// be an issue
			vertex_program_ref BasicVertexPrograms/AmbientOneTextureUnified
			{
				param_named ambient float4 1 1 1 1
			}
			fragment_program_ref BasicFragmentPrograms/PassthroughFP
			{
			}
			scene_blend dest_colour zero
			texture_unit decalmap
			{
				texture RustedMetal.jpg 
			}
			
		}
	}


}

// Any number of lights, diffuse and specular
material BumpMapping/MultiLightSpecular : BumpMapping/MultiLight
{

	// This is the preferred technique which uses both vertex and
	// fragment programs, supports coloured lights
	technique
	{
		// Overlay nothing new onto the old ambient pass
		pass ambient
		{
		}
		// Now do the lighting pass
		// NB we don't do decal texture here because this is repeated per light
		pass perlight
		{

			// Vertex program reference
			vertex_program_ref BumpMapVPSpecular
			{
				param_named_auto lightPosition light_position_object_space 0
				param_named_auto eyePosition camera_position_object_space
				param_named_auto worldViewProj worldviewproj_matrix
			}

			// Fragment program
			fragment_program_ref BumpMapFPSpecular
			{
				param_named_auto lightDiffuse light_diffuse_colour 0 
				param_named_auto lightSpecular light_specular_colour 0
			}
			
		}
		
	}

}

// Any number of lights, diffuse only, correct for tangent parity
material BumpMapping/MultiLightTangentParity : BumpMapping/MultiLight
{

	// This is the preferred technique which uses both vertex and
	// fragment programs, supports coloured lights
	technique
	{
		// Overlay nothing new onto the old ambient pass
		pass ambient
		{
		}
		// Now do the lighting pass
		// NB we don't do decal texture here because this is repeated per light
		pass perlight
		{

			// Just change the vertex program
			vertex_program_ref BumpMapVPTangentParity
			{
				param_named_auto lightPosition light_position_object_space 0
				param_named_auto worldViewProj worldviewproj_matrix
			}
			fragment_program_ref BasicFragmentPrograms/PassthroughFP
			{
			}
			
		}
		
	}

}
